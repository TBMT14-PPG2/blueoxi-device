/**
 ******************************************************************************
 * File Name          : main.c
 * Description        : Main program body
 ******************************************************************************
 *
 * COPYRIGHT(c) 2015 STMicroelectronics
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *   1. Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright notice,
 *      this list of conditions and the following disclaimer in the documentation
 *      and/or other materials provided with the distribution.
 *   3. Neither the name of STMicroelectronics nor the names of its contributors
 *      may be used to endorse or promote products derived from this software
 *      without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************
 */
/* Includes ------------------------------------------------------------------*/
#include "main.h"


#define s_BLUEOXI_SERIAL	1
#define s_BLUEOXI_WIFI		1
#define s_BLUEOXI_MEMORY	1
#define s_BLUEOXI_BLE		1


#define s_MEMORY_BLOCKS		2//40

/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */
/* Private variables ---------------------------------------------------------*/

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);

/* USER CODE BEGIN PFP */
/* Private function prototypes -----------------------------------------------*/

/* USER CODE END PFP */

/* USER CODE BEGIN 0 */

const uint8_t image[13][122] =
{
		0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,
		0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,
		0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,
		0xff,0xff,0xff,0xff,0xff,0xf8,0x1,0xff,0xff,0xff,0xff,0xff,0xf0,
		0xff,0xff,0xff,0xff,0xfe,0x0,0x0,0x7,0xff,0xff,0xff,0xff,0xf0,
		0xff,0xff,0xff,0xff,0xf0,0x0,0x0,0x0,0xff,0xff,0xff,0xff,0xf0,
		0xff,0xff,0xff,0xff,0x80,0x0,0x0,0x0,0x1f,0xff,0xff,0xff,0xf0,
		0xff,0xff,0xff,0xfe,0x0,0x0,0x0,0x0,0x3,0xff,0xff,0xff,0xf0,
		0xff,0xff,0xff,0xf0,0x0,0x0,0x0,0x0,0x0,0xff,0xff,0xff,0xf0,
		0xff,0xff,0xff,0xe0,0x0,0x0,0x0,0x0,0x0,0x7f,0xff,0xff,0xf0,
		0xff,0xff,0xff,0x80,0x0,0x0,0x0,0x0,0x0,0x1f,0xff,0xff,0xf0,
		0xff,0xff,0xfe,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0xff,0xff,0xf0,
		0xff,0xff,0xfc,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0xff,0xff,0xf0,
		0xff,0xff,0xf8,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0xff,0xff,0xf0,
		0xff,0xff,0xe0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7f,0xff,0xf0,
		0xff,0xff,0xc0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3f,0xff,0xf0,
		0xff,0xff,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f,0xff,0xf0,
		0xff,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf,0xff,0xf0,
		0xff,0xfe,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0xff,0xf0,
		0xff,0xfc,0x0,0x0,0x0,0xc0,0x0,0x0,0x0,0x0,0x3,0xff,0xf0,
		0xff,0xfc,0x0,0x0,0x1,0xe0,0x0,0x0,0x0,0x0,0x3,0xff,0xf0,
		0xff,0xf8,0x0,0x0,0x3,0xf0,0x0,0x0,0x0,0x0,0x1,0xff,0xf0,
		0xff,0xf0,0x0,0x0,0x3,0xf0,0x0,0x0,0x0,0x0,0x0,0xff,0xf0,
		0xff,0xe0,0x0,0x0,0x7,0xf8,0x0,0x0,0x0,0x0,0x0,0x7f,0xf0,
		0xff,0xe0,0x0,0x0,0x7,0xb8,0x0,0x0,0x0,0x0,0x0,0x7f,0xf0,
		0xff,0xc0,0x0,0x0,0x7,0x3c,0x0,0x0,0x0,0x0,0x0,0x3f,0xf0,
		0xff,0x80,0x0,0x0,0x7,0x1c,0x0,0x0,0x0,0x0,0x0,0x3f,0xf0,
		0xff,0x80,0x0,0x0,0x7,0x1e,0x0,0x0,0x0,0x0,0x0,0x1f,0xf0,
		0xff,0x0,0x0,0x0,0xf,0xe,0x0,0x0,0x0,0x0,0x0,0xf,0xf0,
		0xff,0x0,0x0,0x0,0xf,0xe,0x0,0x0,0x0,0x0,0x0,0xf,0xf0,
		0xfe,0x0,0x0,0x0,0xe,0xf,0x0,0x0,0x0,0x0,0x0,0x7,0xf0,
		0xfe,0x0,0x0,0x0,0xe,0x7,0x0,0x0,0x0,0x0,0x0,0x7,0xf0,
		0xfe,0x0,0x0,0x0,0xe,0x7,0x0,0x0,0x0,0x0,0x0,0x7,0xf0,
		0xfc,0x0,0x0,0x0,0xe,0x7,0x80,0x0,0x0,0x0,0x0,0x3,0xf0,
		0xfc,0x0,0x0,0x0,0xe,0x3,0x80,0x0,0x0,0x0,0x0,0x3,0xf0,
		0xf8,0x0,0x0,0x0,0xe,0x3,0xc0,0x0,0x0,0x0,0x0,0x1,0xf0,
		0xf8,0x0,0x0,0x0,0x1e,0x1,0xc0,0x0,0x0,0x0,0x0,0x1,0xf0,
		0xf8,0x0,0x0,0x0,0x1e,0x1,0xc0,0x0,0x0,0x0,0x0,0x1,0xf0,
		0xf8,0x0,0x0,0x0,0x1c,0x1,0xc0,0x0,0x0,0x0,0x0,0x1,0xf0,
		0xf0,0x0,0x0,0x0,0x1c,0x1,0xe0,0x0,0x0,0x0,0x0,0x0,0xf0,
		0xf0,0x0,0x0,0x0,0x1c,0x0,0xe0,0x0,0x0,0x0,0x0,0x0,0xf0,
		0xf0,0x0,0x0,0x0,0x1c,0x0,0xe0,0x0,0x0,0x0,0x0,0x0,0xf0,
		0xf0,0x0,0x0,0x0,0x1c,0x0,0xf0,0x0,0x0,0x0,0x0,0x0,0xf0,
		0xf0,0x0,0x0,0x0,0x1c,0x0,0x70,0x0,0x0,0x0,0x0,0x0,0xf0,
		0xe0,0x0,0x0,0x0,0x3c,0x0,0x70,0x1,0xe0,0x0,0x0,0x0,0x70,
		0xe0,0x0,0x0,0x0,0x3c,0x0,0x78,0x3,0xf8,0x0,0x0,0x0,0x70,
		0xe0,0x0,0x0,0x0,0x38,0x0,0x38,0x7,0xfc,0x0,0x0,0x0,0x70,
		0xe0,0x0,0x0,0x0,0x38,0x0,0x38,0xf,0x3e,0x0,0x0,0x0,0x70,
		0xe0,0x0,0x0,0x0,0x38,0x0,0x3c,0xe,0x1e,0x0,0x0,0x0,0x70,
		0xe0,0x0,0x0,0x0,0x78,0x0,0x1c,0x1e,0xf,0x0,0x0,0x0,0x70,
		0xe0,0x0,0x0,0x0,0x78,0x0,0x1c,0x1c,0x7,0x80,0x0,0x0,0x70,
		0xe0,0x0,0x0,0x0,0x70,0x0,0x1e,0x3c,0x7,0x80,0x0,0x0,0x70,
		0xe0,0x0,0x0,0x0,0x70,0x0,0xe,0x38,0x3,0xc0,0x0,0x0,0x70,
		0xe0,0x0,0x0,0x0,0xf0,0x0,0xf,0x38,0x1,0xc0,0x0,0x0,0x70,
		0xe0,0x0,0x0,0x0,0xe0,0x0,0xf,0x78,0x1,0xe0,0x0,0x0,0x70,
		0xe0,0x0,0x0,0x1,0xe0,0x0,0x7,0xf0,0x0,0xf0,0x0,0x0,0x70,
		0xf0,0x0,0x0,0x1,0xc0,0x0,0x3,0xf0,0x0,0x70,0x0,0x0,0xf0,
		0xf0,0x0,0x0,0x3,0xc0,0x0,0x3,0xe0,0x0,0x78,0x0,0x0,0xf0,
		0xf0,0x0,0x0,0x7,0x80,0x0,0x1,0xe0,0x0,0x3c,0x0,0x0,0xf0,
		0xf0,0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x1c,0x0,0x0,0xf0,
		0xf0,0x0,0x0,0xf,0x0,0x0,0x0,0x0,0x0,0x1e,0x0,0x0,0xf0,
		0xf8,0x0,0x0,0x1e,0x0,0x0,0x0,0x0,0x0,0xf,0x0,0x1,0xf0,
		0xf8,0x0,0x0,0x7c,0x0,0x0,0x0,0x0,0x0,0x7,0x80,0x1,0xf0,
		0xf8,0x0,0x0,0xf8,0x0,0x0,0x0,0x0,0x0,0x3,0xe0,0x1,0xf0,
		0xf8,0x0,0x7,0xf0,0x0,0x0,0x0,0x0,0x0,0x1,0xf0,0x1,0xf0,
		0xff,0xc0,0x7f,0xc0,0x0,0x0,0x0,0x0,0x0,0x0,0xff,0xff,0xf0,
		0xff,0xff,0xff,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x7f,0xff,0xf0,
		0xff,0xff,0xfc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f,0xff,0xf0,
		0xff,0xff,0xe0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff,0xf0,
		0xfe,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0xf0,
		0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf,0xf0,
		0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf,0xf0,
		0xff,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f,0xf0,
		0xff,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f,0xf0,
		0xff,0xc0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3f,0xf0,
		0xff,0xe0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7f,0xf0,
		0xff,0xe0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7f,0xf0,
		0xff,0xf0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff,0xf0,
		0xff,0xf8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0xff,0xf0,
		0xff,0xf8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0xff,0xf0,
		0xff,0xfc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0xff,0xf0,
		0xff,0xfe,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0xff,0xf0,
		0xff,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf,0xff,0xf0,
		0xff,0xff,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f,0xff,0xf0,
		0xff,0xff,0xc0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3f,0xff,0xf0,
		0xff,0xff,0xe0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7f,0xff,0xf0,
		0xff,0xff,0xf0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff,0xff,0xf0,
		0xff,0xff,0xfc,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0xff,0xff,0xf0,
		0xff,0xff,0xfe,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0xff,0xff,0xf0,
		0xff,0xff,0xff,0x80,0x0,0x0,0x0,0x0,0x0,0x1f,0xff,0xff,0xf0,
		0xff,0xff,0xff,0xc0,0x0,0x0,0x0,0x0,0x0,0x3f,0xff,0xff,0xf0,
		0xff,0xff,0xff,0xf0,0x0,0x0,0x0,0x0,0x0,0xff,0xff,0xff,0xf0,
		0xff,0xff,0xff,0xfc,0x0,0x0,0x0,0x0,0x3,0xff,0xff,0xff,0xf0,
		0xff,0xff,0xff,0xff,0x0,0x0,0x0,0x0,0xf,0xff,0xff,0xff,0xf0,
		0xff,0xff,0xff,0xff,0xe0,0x0,0x0,0x0,0x7f,0xff,0xff,0xff,0xf0,
		0xff,0xff,0xff,0xff,0xfe,0x0,0x0,0x3,0xff,0xff,0xff,0xff,0xf0,
		0xff,0xff,0xff,0xff,0xff,0xe0,0x0,0x7f,0xff,0xff,0xff,0xff,0xf0,
		0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,
		0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,
		0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,
		0xff,0xe3,0xff,0xcf,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,
		0xff,0xe3,0xff,0xcf,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,
		0xff,0xe3,0xff,0xcf,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0xff,0xf0,
		0xff,0xe3,0xff,0xcf,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x7f,0xf0,
		0xff,0xe3,0xff,0xcf,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x7f,0xf0,
		0xff,0xe3,0xff,0xcf,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0xff,0xf0,
		0xff,0xe3,0xff,0xcf,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,
		0xff,0xe3,0xff,0xcf,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,
		0xff,0xe3,0xff,0xcf,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,
		0xff,0xe2,0xf,0xce,0x3e,0x3e,0x7,0xf0,0x3f,0x1f,0x1c,0x7f,0xf0,
		0xff,0xe0,0x3,0xce,0x3e,0x3c,0x3,0xe0,0xf,0xe,0x3c,0x7f,0xf0,
		0xff,0xe0,0xc3,0xce,0x3e,0x38,0xf1,0xc3,0x7,0x84,0x3c,0x7f,0xf0,
		0xff,0xe3,0xe1,0xce,0x3e,0x38,0xf9,0x87,0xc7,0xc0,0x7c,0x7f,0xf0,
		0xff,0xe3,0xf1,0xce,0x3e,0x31,0xf8,0x8f,0xc7,0xc0,0xfc,0x7f,0xf0,
		0xff,0xe3,0xf1,0xce,0x3e,0x30,0x0,0x8f,0xe3,0xe1,0xfc,0x7f,0xf0,
		0xff,0xe7,0xf1,0xce,0x3e,0x30,0x0,0x8f,0xe3,0xe0,0xfc,0x7f,0xf0,
		0xff,0xe3,0xf1,0xce,0x3e,0x31,0xff,0x8f,0xe3,0xc0,0xfc,0x7f,0xf0,
		0xff,0xe3,0xf1,0xce,0x3e,0x31,0xff,0x8f,0xc7,0x84,0x7c,0x7f,0xf0,
		0xff,0xe1,0xe1,0xcf,0x1e,0x38,0xf8,0xc7,0xc7,0x8c,0x3c,0x7f,0xf0,
		0xff,0xe0,0x3,0xcf,0x8,0x38,0x71,0xc0,0xf,0x1e,0x1c,0x7f,0xf0,
		0xff,0xe0,0x7,0xcf,0x80,0x7c,0x3,0xe0,0x1e,0x1f,0x1c,0x7f,0xf0,
		0xff,0xff,0xf,0xff,0xc1,0xff,0xf,0xf8,0x3f,0xff,0xff,0xff,0xf0
};

/* USER CODE END 0 */

int main(void)
{
	// ----- Local Vairables -----
	uint32_t i;
	uint8_t exit;
	uint32_t final2, final1;
	uint16_t data;
	uint8_t str[32];
	uint8_t chargingStatus = 0;
	uint8_t stream = 0;


	// PPG
	uint8_t		ppgI = 0, ppgSend = 0, ppgSwitch = 0;
	uint16_t	*redBuf, *irBuf, *redSend, *irSend;
	uint16_t	ppgRedData[32], ppgIrData[32];
	uint16_t	ppgRedData2[32], ppgIrData2[32];
	uint16_t	ppgRedFilt[32], ppgIrFilt[32];
	uint16_t 	ppgCount = 0;

	uint16_t 	ppgPeak;

	// MEMORY BUFFERS AND STUFF
	uint8_t flashData[256];
	FlashInfo_t flashInfo;
	uint8_t		memI = 0, memSend = 0, memSwitch = 0;
	uint16_t	*memBuf, *memBuf2;
	uint16_t	memData[128], memData2[128];
	uint32_t	memAddr = s_FLASH__PARAMETER_BLOCK_SIZE;
	uint8_t		memSendBuff[32];



	uint32_t updateTimer;

	uint8_t menuOption = 0;


	/* MCU Configuration----------------------------------------------------------*/

	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();
	/* Configure the system clock */
	SystemClock_Config();
	/* Initialize all configured peripherals */
	MX_GPIO_Init();

	// ----- Init power -----
	Power_Init();
	// Turn on LCD
	s_POWER__LCD_EN_SET();
	// TODO: Turn on BLE because of faulty chip
	s_POWER__BLE_MEMS_EN_SET();

	// ----- Init buttons -----
	Buttons_Init();

	// ----- Init display and show splash screen
	GraphicsObj_t graphObj;
	Graphics_Init(&graphObj);
	Graphics_ClearBuffer(&graphObj, s_GRAPHICS_COLOR__WHITE);

	SharpLcd_Init();
	SharpLcd_PowerOn();
	SharpLcd_Clear();

	Graphics_DrawBitmap(&graphObj, 22, 23, (uint8_t *)image, 100, 122, s_GRAPHICS_COLOR__BLACK);
	//Graphics_DrawString(&graphObj, 10, 10, (uint8_t *)"Hello World!", s_GRAPHICS_COLOR__BLACK);
	SharpLcd_DisplayBuffer(graphObj.pBuf);
	HAL_Delay(2000);

	//Gui_UpdateValues(&graphObj, 0, 0, 0, 0);
	//SharpLcd_DisplayBuffer(graphObj.pBuf);

	// ----- Init LED -----
	WS2812B_Init();
	WS2812B_SendColor(0,16,0);

	// Display menu
	Gui_DisplayMenu(&graphObj, Power_BateryLevel(), chargingStatus);

	// Update timer
	updateTimer = HAL_GetTick();

	// Wait for decision
	while(1)
	{

		menuOption = Gui_DisplayMainMenu(&graphObj);


		//		// Check battery
		//		if((HAL_GetTick() - updateTimer) > 10000) {
		//			updateTimer = HAL_GetTick();
		//
		//			// Check charging
		//			if(s_POWER__CHARGE_STAT_ISSET()) {
		//				chargingStatus = 0;
		//			}
		//			else {
		//				chargingStatus = 1;
		//			}
		//
		//			// Update menu
		//			Gui_DisplayMenu(&graphObj, Power_BateryLevel(), chargingStatus);
		//
		//		}

		// Check all the buttons
		if(menuOption == 0) {
			//		if(g_Buttons_TopPressEvent == 1) {
			//			// Clear event
			//			Buttons_ClearAllEvents();

			// Init Wifi
			Gui_InitWifi(&graphObj);

			// Wait for Start
			Gui_DisplayButtonPrompt(&graphObj, (uint8_t *)"Start!", s_GUI_BUTTONS__MID, s_GUI_DISPLAY_OPT__CLEAR_DISPLAY);
			while(!g_Buttons_MidPressEvent);

			// Init PPG sensor
			if(Gui_InitPpg(&graphObj) == s_ERROR) {
				break;
			}

			// Connect to server
			Gui_ConnectWifi(&graphObj);

			// Stream data
			Gui_DisplayCenterString(&graphObj, (uint8_t *)"Streaming...", 1, 1, s_GUI_DISPLAY_OPT__CLEAR_DISPLAY);
			exit = 1;
			while(exit)
			{
				if(g_Afe44xx_AdcRdy == 1)
				{
					g_Afe44xx_AdcRdy = 0;

					final2 = Afe44xx_ReadRegister(s_AFE44XX__LED2_ALED2VAL);
					final1 = Afe44xx_ReadRegister(s_AFE44XX__LED1_ALED1VAL);

					data = (final1>>8)&0xFFFF;
					Wifi_TxData((uint8_t*)&data, sizeof(data));
					data = (final2>>8)&0xFFFF;
					Wifi_TxData((uint8_t*)&data, sizeof(data));
				}
			}

		}
		else if(menuOption == 1) {
			//		else if(g_Buttons_MidPressEvent == 1) {
			//			// Clear event
			//			Buttons_ClearAllEvents();

			// Init USB
			Gui_InitUsb(&graphObj);

			// Wait for Start
			Gui_DisplayButtonPrompt(&graphObj, (uint8_t *)"Start!", s_GUI_BUTTONS__MID, s_GUI_DISPLAY_OPT__CLEAR_DISPLAY);
			while(!g_Buttons_MidPressEvent);

			// Init PPG sensor
			if(Gui_InitPpg(&graphObj) == s_ERROR) {
				break;
			}

			// Stream data
			Gui_DisplayCenterString(&graphObj, (uint8_t *)"Streaming...", 1, 1, s_GUI_DISPLAY_OPT__CLEAR_DISPLAY);
			exit = 1;
			while(exit)
			{
				if(g_Afe44xx_AdcRdy == 1)
				{
					g_Afe44xx_AdcRdy = 0;

					final2 = Afe44xx_ReadRegister(s_AFE44XX__LED2_ALED2VAL);
					final1 = Afe44xx_ReadRegister(s_AFE44XX__LED1_ALED1VAL);

					data = (final1>>8)&0xFFFF;
					Comm_TxData((uint8_t*)&data, sizeof(data));
					data = (final2>>8)&0xFFFF;
					Comm_TxData((uint8_t*)&data, sizeof(data));
				}
			}

		}
		else if(menuOption == 2) {
			//		else if(g_Buttons_BotPressEvent == 1) {
			// Clear event
			//			Buttons_ClearAllEvents();

			// Ask if streaming is required
			stream = Gui_DisplayStreamMenu(&graphObj);

			// Init BLE
			Gui_InitBle(&graphObj);

			// Init Wifi
			if(stream == 1) {
				Gui_InitWifi(&graphObj);
			}
			// Init USB
			else if(stream == 2) {
				Gui_InitUsb(&graphObj);
			}

			// Wait for Start
			Gui_DisplayButtonPrompt(&graphObj, (uint8_t *)"Start!", s_GUI_BUTTONS__MID, s_GUI_DISPLAY_OPT__CLEAR_DISPLAY);
			while(!g_Buttons_MidPressEvent);

			// Init PPG sensor
			if(Gui_InitPpg(&graphObj) == s_ERROR) {
				break;
			}

			// Connect to server
			if(stream == 1) {
				Gui_ConnectWifi(&graphObj);
			}

			// Setup PPG and buffers
			Ppg_Init();
			redBuf = ppgRedData;
			irBuf = ppgIrData;
			redSend = ppgRedData2;
			irSend = ppgIrData2;
			// Update timer
			updateTimer = HAL_GetTick();
			// Display GUI
			Gui_UpdateValues(&graphObj, 0, 0, 0, 0);


			exit = 1;
			while(exit)
			{
				if(g_Afe44xx_AdcRdy == 1)
				{
					g_Afe44xx_AdcRdy = 0;

					final2 = Afe44xx_ReadRegister(s_AFE44XX__LED2_ALED2VAL);
					final1 = Afe44xx_ReadRegister(s_AFE44XX__LED1_ALED1VAL);

					data = (final1>>8)&0xFFFF;
					irBuf[ppgI] = data;
					data = (final2>>8)&0xFFFF;
					redBuf[ppgI] = data;

					// Buffer signal for SpO2 calculation
					Ppg_BufferSignal(redBuf[ppgI], irBuf[ppgI]);

					ppgI = (ppgI + 1) % 32;

					if(ppgI == 0)
					{
						// Activate sending
						ppgSend = 1;
						// switch buffers
						if(ppgSwitch == 0) {
							redBuf = ppgRedData2;
							irBuf = ppgIrData2;
							redSend = ppgRedData;
							irSend = ppgIrData;
							ppgSwitch = 1;
						} else {
							redBuf = ppgRedData;
							irBuf = ppgIrData;
							redSend = ppgRedData2;
							irSend = ppgIrData2;
							ppgSwitch = 0;
						}

						Ppg_Filter(redSend, ppgRedFilt);
						memcpy(redSend, ppgRedFilt, sizeof(ppgRedFilt));
					}

					if(ppgSend == 1) {

						ppgPeak = Ppg_DetectPeak(redSend[ppgI]);

						// Stream Wifi
						if(stream == 1) {
							Wifi_TxData((uint8_t*)&ppgPeak, sizeof(data));
							//Comm_TxData((uint8_t*)&redSend[ppgI], sizeof(data));
							Wifi_TxData((uint8_t*)&irSend[ppgI], sizeof(data));
						}
						// Stream USB
						else if(stream == 2) {
							Comm_TxData((uint8_t*)&ppgPeak, sizeof(data));
							//Comm_TxData((uint8_t*)&redSend[ppgI], sizeof(data));
							Comm_TxData((uint8_t*)&irSend[ppgI], sizeof(data));
						}
					}
				}

				if((HAL_GetTick() - updateTimer) > 500)
				{
					updateTimer = HAL_GetTick();
					// Send BLE
					Ble_SendPulse((uint8_t)g_Ppg_Pulse);
					// Update GUI
					Gui_UpdateValues(&graphObj, 1, g_Ppg_MaxPulsePercent, (uint8_t)g_Ppg_Pulse, (uint8_t)g_Ppg_SpO2);
					SharpLcd_DisplayBuffer(graphObj.pBuf);
				}
				Ble_Process();

			}

		}
		else if(menuOption == 3) {
			// Ask if streaming is required
			stream = Gui_DisplayStreamMenu(&graphObj);


			// Init Flash
			Gui_DisplayCenterString(&graphObj, (uint8_t *)"Setting up", 2, 1, s_GUI_DISPLAY_OPT__CLEAR);
			Gui_DisplayCenterString(&graphObj, (uint8_t *)"Flash...", 2, 2, s_GUI_DISPLAY_OPT__DISPLAY);
			Flash_Init();
			Flash_ReadInfo(&flashInfo);
			memBuf = memData;
			memBuf2 = memData2;
			HAL_Delay(1000);

			Gui_DisplayCenterString(&graphObj, (uint8_t *)"Erasing...", 1, 1, s_GUI_DISPLAY_OPT__CLEAR_DISPLAY);
			// Erase
			for(i = 0; i < s_MEMORY_BLOCKS; i++) {
				Flash_EraseSector(s_FLASH__PARAMETER_SECTOR_COUNT + i);
			}
			HAL_Delay(1000);


			// Init Wifi
			if(stream == 1) {
				Gui_InitWifi(&graphObj);
			}
			// Init USB
			else if(stream == 2) {
				Gui_InitUsb(&graphObj);
			}

			// Wait for Start
			Gui_DisplayButtonPrompt(&graphObj, (uint8_t *)"Start!", s_GUI_BUTTONS__MID, s_GUI_DISPLAY_OPT__CLEAR_DISPLAY);
			while(!g_Buttons_MidPressEvent);

			// Init PPG sensor
			if(Gui_InitPpg(&graphObj) == s_ERROR) {
				break;
			}

			// Connect to server
			if(stream == 1) {
				Gui_ConnectWifi(&graphObj);
			}

			// Record data
			Gui_DisplayCenterString(&graphObj, (uint8_t *)"Recording...", 1, 1, s_GUI_DISPLAY_OPT__CLEAR_DISPLAY);
			exit = 1;
			while(exit)
			{
				if(g_Afe44xx_AdcRdy == 1 && g_Buttons_Event == 1)
				{
					g_Afe44xx_AdcRdy = 0;

					final2 = Afe44xx_ReadRegister(s_AFE44XX__LED2_ALED2VAL);
					final1 = Afe44xx_ReadRegister(s_AFE44XX__LED1_ALED1VAL);

					data = (final1>>8)&0xFFFF;
					memBuf[memI++] = data;
					data = (final2>>8)&0xFFFF;
					memBuf[memI] = data;

					if(memSend == 2)
					{
						//						// Stream Wifi
						//						if(stream == 1) {
						//							Wifi_TxData((uint8_t*)&memBuf[memI-1], sizeof(data));
						//							Wifi_TxData((uint8_t*)&memBuf[memI], sizeof(data));
						//						}
						//						// Stream USB
						//						else if(stream == 2) {
						//							Comm_TxData((uint8_t*)&memBuf[memI-1], sizeof(data));
						//							Comm_TxData((uint8_t*)&memBuf[memI], sizeof(data));
						//						}
					}

					memI = (memI + 1) % 128;

					if(memI == 0 && memSend == 0)
					{
						// Save to memory
						Flash_Program(memAddr, (uint8_t*)memBuf, 256);
						memAddr += 256;

						if(memAddr > (s_FLASH__PARAMETER_BLOCK_SIZE + 65536 * s_MEMORY_BLOCKS))
						{
							memSend = 1;
							memAddr = s_FLASH__PARAMETER_BLOCK_SIZE;

							Gui_DisplayCenterString(&graphObj, (uint8_t *)"Sending...", 1, 1, s_GUI_DISPLAY_OPT__CLEAR_DISPLAY);
						}
					}

					if(memSend == 1)
					{
						Flash_Read(memAddr, memSendBuff, 4);
						memAddr += 4;

						// Stream Wifi
						if(stream == 1) {
							Wifi_TxData(&memSendBuff[0], 2);
							Wifi_TxData(&memSendBuff[2], 2);
						}
						// Stream USB
						else if(stream == 2) {
							Comm_TxData(&memSendBuff[0], 2);
							Comm_TxData(&memSendBuff[2], 2);
						}


						if(memAddr > (s_FLASH__PARAMETER_BLOCK_SIZE + 65536 * s_MEMORY_BLOCKS))
						{
							memSend = 2;
						}
					}
				}
			}
		}
		if(menuOption == 4) {
			// Ask if streaming is required
			stream = Gui_DisplayStreamMenu(&graphObj);


			// Init Flash
			Gui_DisplayCenterString(&graphObj, (uint8_t *)"Setting up", 2, 1, s_GUI_DISPLAY_OPT__CLEAR);
			Gui_DisplayCenterString(&graphObj, (uint8_t *)"Flash...", 2, 2, s_GUI_DISPLAY_OPT__DISPLAY);
			Flash_Init();
			Flash_ReadInfo(&flashInfo);
			memBuf = memData;
			memBuf2 = memData2;
			HAL_Delay(1000);

			// Init Wifi
			if(stream == 1) {
				Gui_InitWifi(&graphObj);
			}
			// Init USB
			else if(stream == 2) {
				Gui_InitUsb(&graphObj);
			}

			// Wait for Start
			Gui_DisplayButtonPrompt(&graphObj, (uint8_t *)"Start!", s_GUI_BUTTONS__MID, s_GUI_DISPLAY_OPT__CLEAR_DISPLAY);
			while(!g_Buttons_MidPressEvent);

			// Connect to server
			if(stream == 1) {
				Gui_ConnectWifi(&graphObj);
			}

			// Send
			memAddr = s_FLASH__PARAMETER_BLOCK_SIZE;
			Gui_DisplayCenterString(&graphObj, (uint8_t *)"Sending...", 1, 1, s_GUI_DISPLAY_OPT__CLEAR_DISPLAY);

			exit = 1;
			memSend = 1;
			while(exit)
			{
				HAL_Delay(1);
				if(memSend == 1)
				{
					Flash_Read(memAddr, memSendBuff, 4);
					memAddr += 4;

					// Stream Wifi
					if(stream == 1) {
						Wifi_TxData(&memSendBuff[0], 2);
						Wifi_TxData(&memSendBuff[2], 2);
					}
					// Stream USB
					else if(stream == 2) {
						Comm_TxData(&memSendBuff[0], 2);
						Comm_TxData(&memSendBuff[2], 2);
					}


					if(memAddr > (s_FLASH__PARAMETER_BLOCK_SIZE + 65536 * s_MEMORY_BLOCKS))
					{
						memSend = 2;
						Gui_DisplayCenterString(&graphObj, (uint8_t *)"Done.", 1, 1, s_GUI_DISPLAY_OPT__CLEAR_DISPLAY);
					}
				}
			}

		}
	}

	// Fatal error
	Gui_DisplayCenterString(&graphObj, (uint8_t *)"Fatal Error.", 2, 1, s_GUI_DISPLAY_OPT__CLEAR);
	Gui_DisplayCenterString(&graphObj, (uint8_t *)"Please restart!", 2, 2, s_GUI_DISPLAY_OPT__DISPLAY);

	// Turn everything off
	s_POWER__WIFI_EN_RESET();
	s_POWER__GPS_EN_RESET();
	s_POWER__PPG_EN_RESET();

	// END OF GAME
	while(1)
	{
	}










	//#ifdef s_BLUEOXI_MEMORY
	//	// Init flash
	//	uint8_t flashData[256];
	//	FlashInfo_t flashInfo;
	//	Flash_Init();
	//	Flash_ReadInfo(&flashInfo);
	//
	//	// Erase
	//	for(i = 0; i < s_MEMORY_BLOCKS; i++) {
	//		Flash_EraseSector(s_FLASH__PARAMETER_SECTOR_COUNT + i);
	//	}
	//#endif



	uint8_t packet[5];
	packet[0] = 0xA5;
	packet[1] = 0;
	packet[2] = 0;
	packet[3] = 0;
	packet[4] = ((packet[0]+packet[1]+packet[2]+packet[3])^0xFF)+1;

	HAL_UART_Transmit_IT(&g_Ble_UartHandle, packet, 5);



	HAL_Delay(1000);



#ifdef s_BLUEOXI_MEMORY
	Comm_Init();
#endif





	//	// MEMORY BUFFERS AND STUFF
	//	uint8_t		memI = 0, memSend = 0, memSwitch = 0;
	//	uint16_t	*memBuf, *memBuf2;
	//	uint16_t	memData[128], memData2[128];
	//	uint32_t	memAddr = s_FLASH__PARAMETER_BLOCK_SIZE;
	//	uint8_t		memSendBuff[32];

	memBuf = memData;
	memBuf2 = memData2;




	WS2812B_SendColor(0,128,128);



	//	uint32_t bleSendTimer = HAL_GetTick();

	while (1)
	{



#ifdef s_BLUEOXI_SERIAL
		//Check if ADC ready
		if(g_Afe44xx_AdcRdy == 1 && g_Buttons_Event == 1)
		{

			g_Afe44xx_AdcRdy = 0;

			final2 = Afe44xx_ReadRegister(s_AFE44XX__LED2_ALED2VAL);
			final1 = Afe44xx_ReadRegister(s_AFE44XX__LED1_ALED1VAL);

			//			data = (final1>>8)&0xFFFF;
			//			Comm_TxData((uint8_t*)&data, sizeof(data));
			//			data = ppgCount++;
			//			Comm_TxData((uint8_t*)&data, sizeof(data));

			data = (final1>>8)&0xFFFF;
			irBuf[ppgI] = data;
			data = (final2>>8)&0xFFFF;
			redBuf[ppgI] = data;
			//irBuf[ppgI] = ppgCount++;

			// Buffer signal for SpO2 calculation
			Ppg_BufferSignal(redBuf[ppgI], irBuf[ppgI]);

			ppgI = (ppgI + 1) % 32;

			if(ppgI == 0)
			{
				// Activate sending
				ppgSend = 1;
				// switch buffers
				if(ppgSwitch == 0) {
					redBuf = ppgRedData2;
					irBuf = ppgIrData2;
					redSend = ppgRedData;
					irSend = ppgIrData;
					ppgSwitch = 1;
				} else {
					redBuf = ppgRedData;
					irBuf = ppgIrData;
					redSend = ppgRedData2;
					irSend = ppgIrData2;
					ppgSwitch = 0;
				}

				Ppg_Filter(redSend, ppgRedFilt);
				memcpy(redSend, ppgRedFilt, sizeof(ppgRedFilt));
			}


			if(ppgSend == 1) {

				ppgPeak = Ppg_DetectPeak(redSend[ppgI]);

				Comm_TxData((uint8_t*)&ppgPeak, sizeof(data));
				//Comm_TxData((uint8_t*)&g_Ppg_SpO2, sizeof(data));
				//Comm_TxData((uint8_t*)&redSend[ppgI], sizeof(data));
				Comm_TxData((uint8_t*)&irSend[ppgI], sizeof(data));
			}
		}
#endif



#ifdef s_BLUEOXI_BLE
		// BLE send pulse
		if((HAL_GetTick() - updateTimer) > 500)
		{
			updateTimer = HAL_GetTick();
			//Ble_SendPulse((uint8_t)g_Ppg_Pulse);

			if(g_Ble_UartTxReady == 1) {
				g_Ble_UartTxReady = 0;

				packet[1] = 0;
				packet[2] = (uint8_t)g_Ppg_Pulse;
				packet[4] = ((packet[0]+packet[1]+packet[2]+packet[3])^0xFF)+1;

				HAL_UART_Transmit_IT(&g_Ble_UartHandle, packet, 5);

				Gui_UpdateValues(&graphObj, 1, g_Ppg_MaxPulsePercent, (uint8_t)g_Ppg_Pulse, (uint8_t)g_Ppg_SpO2);
				SharpLcd_DisplayBuffer(graphObj.pBuf);
			}

		}
		Ble_Process();
#endif

#ifdef s_BLUEOXI_MEMORY
		//Check if ADC ready
		if(g_Afe44xx_AdcRdy == 1 && g_Buttons_Event == 1)
		{
			g_Afe44xx_AdcRdy = 0;

			final2 = Afe44xx_ReadRegister(s_AFE44XX__LED2_ALED2VAL);
			final1 = Afe44xx_ReadRegister(s_AFE44XX__LED1_ALED1VAL);

			data = (final1>>8)&0xFFFF;
			memBuf[memI++] = data;
			data = (final2>>8)&0xFFFF;
			memBuf[memI] = data;


			if(memSend == 2)
			{
				Comm_TxData((uint8_t*)&memBuf[memI-1], sizeof(data));
				Comm_TxData((uint8_t*)&memBuf[memI], sizeof(data));
			}

			memI = (memI + 1) % 128;

			if(memI == 0 && memSend == 0)
			{
				// switch buffers
				//				if(memSwitch == 0) {
				//					memRedBuf = memRedData2;
				//					memIrBuf = memIrData2;
				//					memRedSave = memRedData;
				//					memIrSave = memIrData;
				//					memSwitch = 1;
				//				} else {
				//					memRedBuf = memRedData;
				//					memIrBuf = memIrData;
				//					memRedSave = memRedData2;
				//					memIrSave = memIrData2;
				//					memSwitch = 0;
				//				}

				// Save to memory
				Flash_Program(memAddr, (uint8_t*)memBuf, 256);
				memAddr += 256;

				if(memAddr > (s_FLASH__PARAMETER_BLOCK_SIZE + 65536 * s_MEMORY_BLOCKS))
				{
					memSend = 1;
					memAddr = s_FLASH__PARAMETER_BLOCK_SIZE;
				}
			}

			if(memSend == 1)
			{
				Flash_Read(memAddr, memSendBuff, 4);
				memAddr += 4;

				Comm_TxData(&memSendBuff[0], 2);
				Comm_TxData(&memSendBuff[2], 2);

				if(memAddr > (s_FLASH__PARAMETER_BLOCK_SIZE + 65536 * s_MEMORY_BLOCKS))
				{
					memSend = 2;
				}
			}
		}
#endif


	}
	/* USER CODE END 3 */

}

/** System Clock Configuration
 */
void SystemClock_Config(void)
{
	RCC_OscInitTypeDef RCC_OscInitStruct;
	RCC_ClkInitTypeDef RCC_ClkInitStruct;

	__PWR_CLK_ENABLE();

	__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);

	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
	RCC_OscInitStruct.PLL.PLLM = 8;
	RCC_OscInitStruct.PLL.PLLN = 336;
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
	RCC_OscInitStruct.PLL.PLLQ = 7;
	HAL_RCC_OscConfig(&RCC_OscInitStruct);

	RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
	HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);

	HAL_RCC_MCOConfig(RCC_MCO1, RCC_MCO1SOURCE_HSE, RCC_MCODIV_1);

	HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);

	HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);

}


/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

#ifdef USE_FULL_ASSERT

/**
 * @brief Reports the name of the source file and the source line number
 * where the assert_param error has occurred.
 * @param file: pointer to the source file name
 * @param line: assert_param error line source number
 * @retval None
 */
void assert_failed(uint8_t* file, uint32_t line)
{
	/* USER CODE BEGIN 6 */
	/* User can add his own implementation to report the file name and line number,
    ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
	/* USER CODE END 6 */

}

#endif

/**
 * @}
 */

/**
 * @}
 */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
